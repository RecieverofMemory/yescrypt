
              The yescrypt Password-Based Key Derivation Function
                                     DRAFT

                     Alexander Peslyak <solar@openall.com>
                        Taylor Hornby <havoc@defuse.ca>

                                 July 10, 2015

Abstract

    This document defines the yescrypt algorithm. The authoritative
    specification of the yescrypt algorithm can be found in [1] and the
    reference implementation can be found in [2]. Here, we specify yescrypt
    independently of scrypt [3] to ease implementation.

Copyright

    - TODO: Decide on the copyright of this document. It will probably be
      some kind of permissive license.

1. Introduction

    Yescrypt [1] is a password-based key derivation function. It applies slow
    cryptographic operations to a password, converting it into a stronger key
    that can be used to perform encryption, or can be stored to validate the
    password in the future.

    Yescrypt is based on scrypt by Colin Percival of Tarsnap [3].

    In the next section, we describe the parameters yescrypt takes. After that,
    we describe the constants and data types used by the algorithm. Finally, we
    describe yescrypt in terms of functions and give pseudocode for their
    implementations.

2. Parameters

    The yescrypt algorithm accepts the following parameters:

        Password    - The password from which to derive the key.

        Salt        - A random string that is unique to this password.

        N           - Increasing N increases running time and memory use.

        R           - Increasing R increases the size of the blocks operated on
                      by the algorithm (and thus increases memory use).

        P           - Parallelism factor.

        T           - Increasing T increases running time without increasing
                      memory use.

        G           - The number of times the hash has been "upgraded."

        Flags       - Has the value 0, YESCRYPT_RW, or YESCRYPT_WORM.

        [Rom]       - (Optional) An array of ??? what constraints TODO

        DKLen       - The length of key to derive (output).

    Upon completion, yescrypt returns an array of DKLen bytes, which is a key
    derived from the Password and Salt according to the other parameters.

    - TODO: describe the limitations on the parameters here, and what G is.

    - TODO: Explain what will overflow, etc when which parameters are too big.

3. Constants

3.1. Configurable Constants

    - TODO: We can simplify the description a lot if we assume these are fixed
      and unchanging (i.e. PWXWORDS == 16 which is a 'cell')

    PWXSIMPLE = 2
    PWXGATHER = 4
    PWXROUNDS = 6
    SWIDTH    = 8

3.2. Derived Constants

    The derived constants are derived from the configurable constants.

    PWXBYTES = PWXGATHER * PWXSIMPLE * 8
    PWXWORDS = PWXBYTES / 4
    SBYTES   = 2 * (2^SWIDTH) * PWXSIMPLE * 8
    SWORDS   = SBYTES / 4
    SMASK    = ((2^SWIDTH) - 1) * PWXSIMPLE * 8
    RMIN     = (PWXBYTES + 127) / 128

4. Data Types

    The fundamental data type operated on by yescrypt is little-endian encoded
    32-bit integers. For the remainder of this document, we refer to them as
    "words."

    A "cell" is an array of 16 words.

    A "block" is an array of 2*R cells, where R is a yescrypt parameter as
    defined above.

    We assume integer parameters and loop counters are contained in 64-bit
    unsigned integers. The necessary overflow checks have been omitted from the
    psuedocode in this document.

5. Functions

5.1. yescrypt

    Input:

        Password

        Salt

        N

        R

        P

        T

        G

        Flags

        [Rom]

        DKLen

    Output:

        DK          - A key derived from the password and salt according to the
                      other parameters.

    Preconditions:

        - TODO: The preconditions here are kind of complex, think carefully
          (especially about the flags)

    Steps:

        if
            YESCRYPT_RW flag is set AND
            P >= 1 AND
            N/P >= 0x100 AND
            (N/P) * R >= 0x20000
        then
            Password = yescrypt(
                Password,
                Salt,
                N / 2^6,
                R,
                P,
                0,
                0,
                Flags | YESCRYPT_PREHASH,
                32
            )
        end if

        if YESCRYPT_PREHASH flag is set then
            Password = HMAC-SHA256(Password, "yescrypt-prehash")
        else if YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set
            Password = HMAC-SHA256(Password, "yescrypt")
        end if

        B[0], B[1], ..., B[P-1] = PBKDF2-SHA256(Password, Salt, 1, P * 128 * R)

        if YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set then
            Password = The first 32 bytes of B[0]
        end if

        if YESCRYPT_RW flag is set then
            sMix(N, R, T, P, B, Flags)
        else
            for i = 0 to P - 1 do
                sMix(N, R, T, 1, B[i], Flags)
            end
        end if

        Result = PBKDF2-SHA256(Password, B, 1, max(DKLen, 32))

        if
            (YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set) AND
            YESCRYPT_PREHASH flag is *not* set
        then
            ClientValue = First 32 bytes of Result
            ClientKey = HMAC-SHA256("Client Key", ClientValue)
            StoredKey = SHA256(ClientKey)

            Set the first 32 bytes of Result to the StoredKey
        end if

        return the first dkLen bytes of Result

5.2. sMix

    Input:

        N

        R

        T

        P

        Blocks

        Flags

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:

        Allocate P sboxes SBox[0], SBox[1], ..., SBox[P - 1].

        n = N / P

        Nloop_all = fNloop(n, T, Flags)

        if YESCRYPT_RW flag is set
            NLoop_rw = Nloop_all / P
        else
            NLoop_rw = 0
        end

        n = n - (n % 2)

        Nloop_all = Nloop_all + (Nloop_all % 2)
        Nloop_rw = Nloop_rw - (Nloop_rw % 2)

        Allocate N blocks V[0], V[1], ..., V[N-1]

        for i = 0 to p - 1 do
            v = i * n
            if i == p - 1 do
                n = n - v
            end if
            w = v - n - 1

            if YESCRYPT_RW flag is set
                # Note: This call modifies the first two cells of Blocks[i], and
                # that modification must be saved.
                sMix1(1, First two cells of Blocks[i], SBYTES/128, SBox[i], Flags without YESCRYPT_RW, null)
            else
                SBox[i] = null
            end if

            sMix1(R, Blocks[i], n, V[v..w], Flags, SBox[i])

            sMix2(R, Blocks[i], p2floor(n), Nloop_rw, V[v..w], Flags, SBox[i])
        end for

        for i = 0 to p - 1 do
            sMix2(R, B[i], N, Nloop_all - Nloop_rw, V, flags without YESCRYPT_RW, SBox[i])
        end

5.3. sMix1

    Input:

        R

        Block

        N

        OutputBlocks

        Flags

        SBox

    Output:

        The Block and OutputBlocks parameters are modified in-place.

    Preconditions:

    Steps:

        SIMDShuffle(Block)

        for i = 0 to N - 1 do

            OutputBlocks[i] = Block

            # TODO: look at the spec to get the right condition here
            # TODO: pass the ROM down as an explicit parameter
            if false
                # TODO: the ROM thing
            else if YESCRYPT_RW flag is set AND i > 1
                j = wrap(integerify(r, input_block), i)
                Block = Block XOR OutputBlocks[j]
            end if

            if SBox is null
                blockmix_salsa8(R, Block)
            else
                blockmix_pwxform(R, Block, SBox)
            end if

        end for

        SIMDUnshuffle(Block)


5.4. sMix2

    Input:

        R

        Block

        N

        Nloop

        OutputBlocks

        Flags

        Sbox

    Output:

        The Block and OutputBlocks parameters are modified in-place.

    Preconditions:

    Steps:

        SIMDShuffle(Block)

        for i = 0 to NLoop - 1 do

            # TODO: same as above
            if false
                # TODO: ROM stuff
            else
                j = integerify(R, Block) % N

                Block = Block XOR OutputBlocks[j]

                if YESCRYPT_RW flag is set
                    OutputBlocks[j] = Block
                end if
            end if

            if SBox is null
                blockmix_salsa8(R, Block)
            else
                blockmix_pwxform(R, Block, SBox)
            end if
        end for

        SIMDUnshufle(Block)

5.5. blockmix_pwxform

    Input:

        R

        Block

        Sbox

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:

        # TODO: we need to specify that this is integer division
        pwx_blocks = 2 * R * 16 / PWXWORDS

        PWXB = View Block as PWXB[0], PWXB[1], ..., PWXB[pwx_blocks - 1] chunks
               of size PWXWORDS.

        X = PWXB[pwx_blocks - 1]

        for i = 0 to pwx_blocks - 1 do
            if pwx_blocks > 1
                X = X XOR PWXB[i]
            end

            pwxform(X)

            PWXB[i] = X
        end for

        i = (pwx_blocks - 1) * PWXWORDS / 16
        # NOTE: We're getting the i-th cell of Block here.
        salsa20_8(Block[i])

        for i = i + 1 to 2 * r - 1 do
            # TODO: Check this... I think this is right, and actually simpler.
            # (If it is, we don't need that extra array in the Ruby impl.)
            Block[i] = Block[i - 1] XOR Block[i]
            salsa20_8(Block[i])
        end for

5.6. pwxform

    Input:

        Block

        Sbox

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:

        for i = 0 to PWXROUNDS - 1 do
            for j = 0 to PWXGATHER - 1 do

                # TODO: We're mixing cell-indexing and word indexing here...
                x_lo = Block[2 * j * PWXSIMPLE]
                x_hi = Block[2 * j * PWXSIMPLE + 1]

                p0 = (xl & SMASK) / (PWXSIMPLE * 8)
                p1 = (xh & SMASK) / (PWXSIMPLE * 8)

                for k = 0 to PWXSIMPLE - 1 do
                    # TODO: ...
                end

            end for
        end for

5.7. blockmix_salsa8

    Input:

        R

        Block

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:

        X = Block[2 * r - 1]

        Allocate a block Y.

        for i = 0 to 2 * r - 1 do
            X = X XOR Block[i]
            salsa20_8(X)
            if i % 2 == 0
                Y[i/2] = X
            else
                Y[r + (i-1)/2] = X
            end
        end for

        Block = Y

5.8. sala20_8

    Input:

        Words - An array of 16 words.

    Output:

        The Words parameter is modified in-place.

    Preconditions:

    Steps:

        - TODO: Cite the reference for salsa20_8


5.9. fNloop

    Input:

        N

        T

        Flags

    Output:

        Returns an integer.

    Preconditions:

    Steps:


5.10. p2floor

    Input:

        X   - An integer.

    Output:

        Returns an integer.

    Preconditions:

    Steps:


5.11. wrap

    Input:

        X

        L

    Output:

        Returns an integer.

    Preconditions:

    Steps:

5.12. integerify

    Input:

        R

        Block

    Output:

        Returns an integer.

    Preconditions:

    Steps:

5.13. SIMDShuffle

    Input:

    Output:

    Preconditions:

    Steps:

5.14. SIMDUnshufle

    Input:

    Output:

    Preconditions:

    Steps:

5.15. HMAC-SHA256

    Input:

        Key

        Message

    Output:

        A 32-byte result.

    Preconditions:

    Steps:

        - TODO: find the right HMAC reference

5.16. PBKDF2-SHA256

    Input:

        Password

        Salt

        Iterations

        DKLen

    Output:

        A DKLen-byte result.

    Preconditions:

    Steps:

        - TODO: find the right PBKDF2 reference

5.17. SHA256

    Input:

        Message

    Output:

        A 32-byte result.

    Preconditions:


    Steps:

        - TODO: find the right SHA256 reference

6. Test Vectors

    - TODO: auto-generate test vectors from the reference implementation, and
      cross-check them with my implementations

7. Security Considerations

    - TODO: Note that non-optimized implementations are essentially insecure, so
      the implementer needs to know their platform and might need to change
      their implementation from what we implicitly assume (e.g. 32-bit integers)
      in order to be fast.

8. References

    [1] https://password-hashing.net/submissions/specs/yescrypt-v1.pdf
    [2] https://password-hashing.net/submissions/yescrypt-v1.tar.gz
    [3] https://www.tarsnap.com/scrypt/scrypt.pdf
