
              The yescrypt Password-Based Key Derivation Function
                                     DRAFT

                     Alexander Peslyak <solar@openall.com>
                        Taylor Hornby <havoc@defuse.ca>

                                 July 10, 2015

Abstract

    This document defines the yescrypt algorithm. The authoritative
    specification of the yescrypt algorithm can be found in [1] and the
    reference implementation can be found in [2]. Here, we specify yescrypt
    independently of scrypt [3] to ease implementation.

Copyright

    - TODO: Decide on the copyright of this document. It will probably be
      some kind of permissive license.

1. Introduction

    Yescrypt [1] is a password-based key derivation function. It applies slow
    cryptographic operations to a password, converting it into a stronger key
    that can be used to perform encryption, or can be stored to validate the
    password in the future.

    Yescrypt is based on scrypt by Colin Percival of Tarsnap [3].

    In the next section, we describe the parameters yescrypt takes. After that,
    we describe the constants and data types used by the algorithm. Finally, we
    describe yescrypt in terms of functions and give pseudocode for their
    implementations.

    - TODO: We probably need to say more here.

2. Parameters

    The yescrypt algorithm accepts the following parameters:

        Password    - The password from which to derive the key.

        Salt        - A random string that is unique to this password.

        N           - Increasing N increases running time and memory use.

        R           - Increasing R increases the size of the blocks operated on
                      by the algorithm (and thus increases memory use).

        P           - Parallelism factor.

        T           - Increasing T increases running time without increasing
                      memory use.

        G           - The number of times the hash has been "upgraded."

        Flags       - Has the value 0, YESCRYPT_RW, or YESCRYPT_WORM.

        [Rom]       - (Optional) An array of ??? what constraints TODO

        DKLen       - The length of key to derive (output).


    Upon completion, yescrypt returns an array of DKLen bytes, which is a key
    derived from the Password and Salt according to the other parameters.

    - TODO: describe the limitations on the parameters here, and what G is.

3. Constants

3.1. Configurable Constants

    PWXSIMPLE = 2
    PWXGATHeR = 4
    PWXROUNDS = 6
    SWIDTH    = 8

3.2. Derived Constants

    The derived constants are derived from the configurable constants.

    PWXBYTES = PWXGATHER * PWXSIMPLE * 8
    PWXWORDS = PWXBYTES / 4
    SBYTES   = 2 * (1 << SWIDTH) * PWXSIMPLE * 8
    SWORDS   = SBYTES / 4
    SMASK    = ((1 << SWIDTH) - 1) * PWXSIMPLE * 8
    RMIN     = (PWXBYTES + 127) / 128

4. Data Types

    The fundamental data type operated on by yescrypt is little-endian encoded
    32-bit integers. For the remainder of this document, we refer to them as
    "words."

    A "cell" is an array of 16 words.

    A "block" is an array of 2*R cells, where R is a yescrypt parameter as
    defined above.

    - TODO: We need to specify the type for integers holding counters, loop
      limits, memory sizes, etc... scrypt needs 64-bit, but maybe for the sake
      of specification we should just assume unbounded integers? No, I think it
      is important, since sanity checks early on depend on the integer sizes
      being used, to avoid overflow, and it's important for developers to know
      that.

5. Functions

5.1. yescrypt

    Input:

        Password

        Salt

        N

        R

        P

        T

        G

        Flags

        [Rom]

        DKLen

    Output:

        DK          - A key derived from the password and salt according to the
                      other parameters.

    Preconditions:

        - TODO: The preconditions here are kind of complex, think carefully
          (especially about the flags)

    Steps:

        if
            YESCRYPT_RW flag is set AND
            P >= 1 AND
            N/P >= 0x100 AND
            (N/P) * R >= 0x20000
        then
            Password = yescrypt(
                Password,
                Salt,
                N / 2^6,
                R,
                P,
                0,
                0,
                Flags | YESCRYPT_PREHASH,
                32
            )
        end if

        if YESCRYPT_PREHASH flag is set then
            Password = HMAC-SHA256(Password, "yescrypt-prehash")
        else if YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set
            Password = HMAC-SHA256(Password, "yescrypt")
        end if

        B[0], B[1], ..., B[P-1] = PBKDF2-SHA256(Password, Salt, 1, P * 128 * R)

        if YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set then
            Password = The first 32 bytes of B[0]
        end if

        if YESCRYPT_RW flag is set then
            sMix(N, R, T, P, B, Flags)
        else
            for i = 0 to P - 1 do
                sMix(N, R, T, 1, B[i], Flags)
            end
        end if

        Result = PBKDF2-SHA256(Password, B, 1, max(DKLen, 32))

        if
            (YESCRYPT_RW flag is set OR YESCRYPT_WORM flag is set) AND
            YESCRYPT_PREHASH flag is *not* set
        then
            ClientValue = First 32 bytes of Result
            ClientKey = HMAC-SHA256("Client Key", ClientValue)
            StoredKey = SHA256(ClientKey)

            Set the first 32 bytes of Result to the StoredKey
        end if

        return the first dkLen bytes of Result

5.2. sMix

    Input:

        N

        R

        T

        P

        Block

        Flags

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:

5.3. sMix1

    Input:

        R

        Block

        N

        OutputBlocks

        Flags

        Sbox

    Output:

        The Block and OutputBlocks parameters are modified in-place.

    Preconditions:

    Steps:


5.4. sMix2

    Input:

        R

        Block

        N

        Nloop

        OutputBlocks

        Flags

        Sbox

    Output:

        The Block and OutputBlocks parameters are modified in-place.

    Preconditions:

    Steps:


5.5. blockmix_pwxform

    Input:

        R

        Block

        Sbox

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:


5.6. pwxform

    Input:

        Block

        Sbox

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:


5.7. blockmix_salsa8

    Input:

        R

        Block

    Output:

        The Block parameter is modified in-place.

    Preconditions:

    Steps:


5.8. sala20_8

    Input:

        Words - An array of 16 words.

    Output:

        The Words parameter is modified in-place.

    Preconditions:

    Steps:


5.9. fNloop

    Input:

        N

        T

        Flags

    Output:

        Returns an integer.

    Preconditions:

    Steps:


5.10. p2floor

    Input:

        X   - An integer.

    Output:

        Returns an integer.

    Preconditions:

    Steps:


5.11. wrap

    Input:

        X

        L

    Output:

        Returns an integer.

    Preconditions:

    Steps:

5.12. integerify

    Input:

        R

        Block

    Output:

        Returns an integer.

    Preconditions:

    Steps:

5.13. HMAC-SHA256

    Input:

        Key

        Message

    Output:

        A 32-byte result.

    Preconditions:

    Steps:

        - TODO: find the right HMAC reference

5.14. PBKDF2-SHA256

    Input:

        Password

        Salt

        Iterations

        DKLen

    Output:

        A DKLen-byte result.

    Preconditions:

    Steps:

        - TODO: find the right PBKDF2 reference

5.15. SHA256

    Input:

        Message

    Output:

        A 32-byte result.

    Preconditions:


    Steps:

        - TODO: find the right SHA256 reference

6. Test Vectors

    - TODO: auto-generate test vectors from the reference implementation, and
      cross-check them with my implementations

7. Security Considerations

    - TODO: Note that non-optimized implementations are essentially insecure, so
      the implementer needs to know their platform and might need to change
      their implementation from what we implicitly assume (e.g. 32-bit integers)
      in order to be fast.

8. References

    [1] https://password-hashing.net/submissions/specs/yescrypt-v1.pdf
    [2] https://password-hashing.net/submissions/yescrypt-v1.tar.gz
    [3] https://www.tarsnap.com/scrypt/scrypt.pdf
